---
title: "Etude de la végétation de Mafragh"
author: "Aldric, Baptiste, Jeanne, Lucien, Lucile"
date: "2023-10-05"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

Une petite mise en contexte
Ou se situe la plaine du Mafragh ? Quelle est la végétation associée ? Pourquoi relier sol et plantes est pertinent...


## Chargement des packages

```{r cars, include=FALSE}
library(readxl)
#libraries for time series analyses
library(nlme)      #glm and gls
library(tidyverse) # for data cleaning, ordering, etc.

#libraries for spatial series analyses
library(spdep) #to extracted the neighbors is a spatial data
library(ade4)  #used for plotting spatial data
library(spatialreg) #used for spatial data modelling
library(gwrr)  #to run geographically weighted regression
library(ade4)
library(vegan)
library("ggplot2")
library("factoextra")
library(corrplot)
library(RVAideMemoire)
library("PerformanceAnalytics")
library(readxl)

require(questionr)
require(nnet)
require(aod)

require(regclass)
require(car)
```

## Chargement des données

```{r pressure, include=FALSE}
file_path = "data_vegetation_french.xls"

flo = read_excel(file_path, sheet = "flo")
mil = read_excel(file_path, sheet = "mil", col_types = 'numeric')
coord = read_excel(file_path, sheet = "coord", col_types = 'numeric')
association = read_excel(file_path, sheet = "association")

flo_mil = cbind(flo, mil)
```

# Exploration du jeu de données 

## Représentation spaciale

virer xy et mettre coord partout(c'est une colonne du jeu de donnée !)
```{r}
coord
plot(coord)
coord.knear4 = knearneigh(as.matrix(coord),4) #to extract the neighbour points
knn2nb(coord.knear4)
plot(knn2nb(coord.knear4), coord, add=TRUE)


ade4::s.label(coord, ylim=c(min(coord[,1])-50, max(coord[,1])+50) ,xlim=c(min(coord[,2])-50,max(coord[,2])+50),  clabel=0.6,cpoint=1,neig=nb2neig(knn2nb(coord.knear4)))
```

##Représentation des voisins --> on garde ou pas ? pas exploité par la suite...

```{r}
#Gabriel :

veg.gab<-gabrielneigh(as.matrix(coord))
# you can represent it spatially with this function:
#s.label(coord,clabel=.5, cpoint=.1,neig=nb2neig(graph2nb(veg.gab)))

#Delaunay :
veg.tri<-tri2nb(coord)
# graphic representation:
#s.label(coord,clabel=0.6,cpoint=1,neig=nb2neig(veg.tri))
# synthetic view:
veg.tri

#Distance
veg.dnear<-dnearneigh(as.matrix(coord),0,30) #here we specify that ponds are connected if they are appart from less than 30m
# graphic representation:
#s.label(coord,clabel=0.6, cpoint=1,neig=nb2neig(veg.dnear))
# synthetic view:
veg.dnear #in that specific case: the ponds 4 and 31 are not connected to any other pond

par(mfrow=c(1,3))
s.label(coord,clabel=0, cpoint=.1,neig=nb2neig(graph2nb(veg.gab))) 
s.label(coord,clabel=0,cpoint=1,neig=nb2neig(veg.tri))
s.label(coord,clabel=0, cpoint=1,neig=nb2neig(veg.dnear))
```

## Analyses préliminaires 
### Test et standardization

Avant de commencer l'analyse, il s'agit de tester l'homogénéité de la variance avec le test de Bartlett.
Les données sont ensuite standardizées de la façon suivante :
La transformation d'Hellinger est appliquée aux données floristiques.
Les données pédologique (mil) sont centrées et réduite car les unités des variables ne sont pas identiques.

```{r}
bartlett.test(flo)
#pas de normalité car rejet de l'HP de normalité avec la normalité avec la pvalue

#standardization methods : adapt to your own data
flo <- decostand(flo, "hellinger") #package vegan
mil= as.data.frame(scale(mil, center=TRUE, scale=TRUE))
```
Le test de Barlett confirme que nous nous trouvons en situation d'homocédasticité.

### Etude de la corrélation entre variables
#### Pour les données pédologiques 
```{r}
M <- cor(mil)
par(mfrow=c(1,1))
corrplot(M, method = "number")
```

Il existe de rares corrélations entre variables, au seuil 0.7, Na+ est corrélé avec Conduct et Sable avec Argile.
Ce résultat n'est pas surprenant, comme le limon, le sable et l'argile donnent la texture du sol, ces trois variables sont corrélées. 
Pour le moment, toutes les varibales sont concervées. Il s'agira de vérifier s'il reste des corrélations dans les variables qui seront choisies lors de la création de modèle.

#### Pour les données floristiques
```{r}
M <- cor(flo)
corrplot(M, method = "number",type="upper") #pas de corrélation entre les espece.
```
Il n'y a pas de corrélation entre les différentes espèces.

#### Etudes des corrélations entre les données floristiques et pédologiques
```{r}
M <- cor(flo_mil)
corrplot(M, method = "square")  #ni entre esp et envrnt
```
Pas de corrélation entre les espèces et des données pédologiques.

Ces analyses préliminaires nous ont montrées que nous faisons face à de grands tableaux de valeurs mais présentant peu de corrélations entre variables. 
Par la suite, nous allons nous pencher sur la corrélation spaciale


## Etude de l'autocorrélation spaciale 

```{r}
geo = dist(xy)

chim = dist(scale(mil),method = "euclidian") #caclue de la distance entre les points 

# the test used to correlate those two matrix is a Mantel test, it uses randomization of the values 
#to have the expected distribution under H0
# H0: the correlation between teh two matrix is null : there is no spatial autocorrelation
r1 = mantel.rtest(geo,chim,nrepet=1000) 
r1 ##Significatif donc réelle autocorrelation spatiale, pvalue = 0.02 !

plot(r1, main = "Mantel's test")
```

# Etude statistique
## Selection des variables pertinententes

```{r}

###sélection des variables non redondantes (collinéarité)###
rdadoubs=rda(flo~.,mil) #CCA 
first=ordistep(rdadoubs,perm.max=500)
first
mil2=mil[,c("Mg++", "K+", "Capa_Reten", "Altitude")] #c'est le bon modèle, obtenu avec l'ordistep

#allow to check which variables would be selected. Control if they are correlated ?
#I propose to select :
test=vif.cca(first) 
test#problème (>10)
# 
# 
# mil3=mil[,c("Limon","Argile",'Mg++','K+',"Capa_Reten","Altitude")]
selected=as.data.frame(scale(mil2, center=TRUE, scale=TRUE)) #c'est mil2
# rdadoubs3=rda(flo~.,mil3)
# test=vif.cca(rdadoubs3) 
# test#all good
```

## Partitionnement de variance 

On réalise un partionnement de variance pour étudier comment est distribuée la variance du tableau de comptage floristique en fonction des caractéristiques pédologiques du milieu et des cordonnées géographiques.
```{r}
partion_var <- varpart(flo,mil,coord)
plot(partion_var, bg=2:5)
```
Les données pédologiques expliquent 10% de la variance de la distribution floristique. 6% de cette variance sont expliqués par les coordonnées géographique. 
L'interraction entre pédologie et géographie explique 4% de la variance du tableau de comptage des espèces végétales. 
On constate que la majorité de la variance (80%) des espèces végétales n'est pas expliquée par les données dont nous disposons.
Par la suite, nous allons exclure la dépendance spaciale en travaillant sur l'influence du milieu pédologique sur les communautés végétales en réalisant une Analyses des Correspondances en Composantes Principales.

--> Mettre des légendes au graph au lieu de X1 et X2, écrire Milieu et Spacial...

## Principal Component Correspondence Analysis 

L'Analyses des Correspondances en Composantes Principales est réalisée avec le package Vegan.
```{r}
ccap_flo=cca(flo,selected,coord,scan=F)
ccap_flo
```
L'inertie totale du tableau de comptage floristique s'élève à 8.3. 9% de cette inertie est expliquée par les coordonnées géographiques et 9% par les données pédologiques du milieu. C'est donc 80% de l'inertie qui n'est pas expliquée par les tables de valeur dont nous disposons.

Le premier axe représente 50% (0.35/0.7) de la variance expliquée par le milieu pédologique et 4% de la variance totale de la distribution floristique. 

La pCCA est testée à l'aide d'une anova :
```{r}
anova.cca(ccap_flo)
```
Les résultats de la pCCA sont significatifs (pvalue = 0.001).

```{r}
#ccap_flo$CCA$v #coordonnées des especes sur les axes
ccap_flo$CCA$biplot #coordonnées des variables

#MVA.synt(ccap_flo) #conditionnel = 8.78 c'est xy, constrained = 8.94 c'est mil
#par(mfrow=c(1,2))
#plot(ccap_flo,scaling=2)
#goodness(ccap_flo)

```
L'altitude est fortement corrélée négativement au premier axe. La capacité de rétention est fortement corrélée négativement au deuxième axe.

```{r}
#plot the pCCA
par(mfrow=c(1,1))
plot(ccap_flo,scaling=1)
plot(ccap_flo, type="n")
text(ccap_flo, col="blue",cex = 0.75)
text(ccap_flo, dis="cn",col="black",cex = 1.2)
plot(ccap_flo, type="n")
text(ccap_flo, dis="cn",col="black",cex = 1)
text(ccap_flo, "species", col="blue", cex=0.8)
```

# Création d'un modèle à vocation prédictive pour la classe de Association
## Selection du meilleur modèle

```{r}
asso.mlogit = multinom(association$association~.,mil) #modèle multinomial complet
asso = multinom(association$association~1,mil) #modèle multinomial null
beta = coef(asso.mlogit)

model = step(asso, direction = "both", scope = formula(asso.mlogit))
```

Grace à la selection du meilleur modèle, obtenu en minimisant l'AIC, on s'arrête sur les variables K+, Altitude, Capa_Reten et Sable.
```{r}
asso.selected = mil[, c("K+", "Altitude",  "Capa_Reten", "Sable")]
asso.select.mlogit = multinom(association$association~.,asso.selected)
```
On vérifie la multicollinéarité :
```{r}
vif(asso.select.mlogit)
```
La valeur du VIF pour la variable Sable s'élève à 1933, c'est beaucoup trop ! Il s'agira d'enlever cette variable :
```{r}
asso.selected.no.sand = mil[, c("K+", "Altitude",  "Capa_Reten")]
asso.selected.no.sand$K = asso.selected.no.sand$"K+"
asso.selected.no.sand = asso.selected.no.sand[-1]
model_final = multinom(association$association~.,asso.selected.no.sand)

vif(model_final) 
```
Désormais, mode_final ne présentente pas de soucis de multicollinéarité. Nous allons l'utiliser pour réaliser de la prédiction de classe.

## Prédictions
```{r}
proba = predict(model_final, newdata = data.frame(asso.selected.no.sand), type="class")
confusion = table(association$association,proba,dnn=list("Observed","Predicted"))
confusion

## il faudrait la mettre en couleur mais j'ai pas trouvé...

```
--> mettre en couleur cette matrice 