---
title: "Etude de la végétation de Mafragh"
author: "Aldric, Baptiste, Jeanne, Lucien, Lucile"
date: "2023-10-05"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

Une petite mise en contexte
Ou se situe la plaine du Mafragh ? Quelle est la végétation associée ? Pourquoi relier sol et plantes est pertinent...


## Chargement des packages

```{r cars, include=FALSE}
library(readxl)
#libraries for time series analyses
library(nlme)      #glm and gls
library(tidyverse) # for data cleaning, ordering, etc.

#libraries for spatial series analyses
library(spdep) #to extracted the neighbors is a spatial data
library(ade4)  #used for plotting spatial data
library(spatialreg) #used for spatial data modelling
library(gwrr)  #to run geographically weighted regression
library(ade4)
library(vegan)
library("ggplot2")
library("factoextra")
library(corrplot)
library(RVAideMemoire)
library("PerformanceAnalytics")
library(readxl)

require(questionr)
require(nnet)
require(aod)

require(regclass)
require(car)
```

## Chargement des données

```{r pressure, include=FALSE}
file_path = "data_vegetation_french.xls"

flo = read_excel(file_path, sheet = "flo")
mil = read_excel(file_path, sheet = "mil", col_types = 'numeric')
coord = read_excel(file_path, sheet = "coord", col_types = 'numeric')
association = read_excel(file_path, sheet = "association")

flo_mil = cbind(flo, mil)
```

# Exploration du jeu de données 

## Représentation spaciale

virer xy et mettre coord partout(c'est une colonne du jeu de donnée !)
```{r}
coord
plot(coord)
coord.knear4 = knearneigh(as.matrix(coord),4) #to extract the neighbour points
knn2nb(coord.knear4)
plot(knn2nb(coord.knear4), coord, add=TRUE)


ade4::s.label(coord, ylim=c(min(coord[,1])-50, max(coord[,1])+50) ,xlim=c(min(coord[,2])-50,max(coord[,2])+50),  clabel=0.6,cpoint=1,neig=nb2neig(knn2nb(coord.knear4)))
```

##Représentation des voisins --> on garde ou pas ? pas exploité par la suite...

```{r}
#Gabriel :

veg.gab<-gabrielneigh(as.matrix(coord))
# you can represent it spatially with this function:
#s.label(coord,clabel=.5, cpoint=.1,neig=nb2neig(graph2nb(veg.gab)))

#Delaunay :
veg.tri<-tri2nb(coord)
# graphic representation:
#s.label(coord,clabel=0.6,cpoint=1,neig=nb2neig(veg.tri))
# synthetic view:
veg.tri

#Distance
veg.dnear<-dnearneigh(as.matrix(coord),0,30) #here we specify that ponds are connected if they are appart from less than 30m
# graphic representation:
#s.label(coord,clabel=0.6, cpoint=1,neig=nb2neig(veg.dnear))
# synthetic view:
veg.dnear #in that specific case: the ponds 4 and 31 are not connected to any other pond

par(mfrow=c(1,3))
s.label(coord,clabel=0, cpoint=.1,neig=nb2neig(graph2nb(veg.gab))) 
s.label(coord,clabel=0,cpoint=1,neig=nb2neig(veg.tri))
s.label(coord,clabel=0, cpoint=1,neig=nb2neig(veg.dnear))
```

## Analyses préliminaires 
### Test et standardization

Avant de commencer l'analyse, il s'agit de tester l'homogénéité de la variance avec le test de Bartlett.
Les données sont ensuite standardizées de la façon suivante :
La transformation d'Hellinger est appliquée aux données floristiques.
Les données pédologique (mil) sont centrées et réduite car les unités des variables ne sont pas identiques.

```{r}
bartlett.test(flo)
#pas de normalité car rejet de l'HP de normalité avec la normalité avec la pvalue

#standardization methods : adapt to your own data
flo <- decostand(flo, "hellinger") #package vegan
mil= as.data.frame(scale(mil, center=TRUE, scale=TRUE))
```
Le test de Barlett confirme que nous nous trouvons en situation d'homocédasticité.

### Etude de la corrélation entre variables
#### Pour les données pédologiques 
```{r}
M <- cor(mil)
par(mfrow=c(1,1))
corrplot(M, method = "number")
```

Il existe de rares corrélations entre variables, au seuil 0.7, Na+ est corrélé avec Conduct et Sable avec Argile.
Ce résultat n'est pas surprenant, comme le limon, le sable et l'argile donnent la texture du sol, ces trois variables sont corrélées. 
Pour le moment, toutes les varibales sont concervées. Il s'agira de vérifier s'il reste des corrélations dans les variables qui seront choisies lors de la création de modèle.

#### Pour les données floristiques
```{r}
M <- cor(flo)
corrplot(M, method = "number",type="upper") #pas de corrélation entre les espece.
```
Il n'y a pas de corrélation entre les différentes espèces.

#### Etudes des corrélations entre les données floristiques et pédologiques
```{r}
M <- cor(flo_mil)
corrplot(M, method = "square")  #ni entre esp et envrnt
```
Pas de corrélation entre les espèces et des données pédologiques.

Ces analyses préliminaires nous ont montrées que nous faisons face à de grands tableaux de valeurs mais présentant peu de corrélations entre variables. 
Par la suite, nous allons nous pencher sur la corrélation spaciale


## Etude de l'autocorrélation spaciale 

```{r}
geo = dist(xy)

chim = dist(scale(mil),method = "euclidian") #caclue de la distance entre les points 

# the test used to correlate those two matrix is a Mantel test, it uses randomization of the values 
#to have the expected distribution under H0
# H0: the correlation between teh two matrix is null : there is no spatial autocorrelation
r1 = mantel.rtest(geo,chim,nrepet=1000) 
r1 ##Significatif donc réelle autocorrelation spatiale, pvalue = 0.02 !

plot(r1, main = "Mantel's test")
```

# Etude statistique
## Selection des variables pertinententes

```{r}

###sélection des variables non redondantes (collinéarité)###
rdadoubs=rda(flo~.,mil) #CCA 
first=ordistep(rdadoubs,perm.max=500)
first
mil2=mil[,c("Mg++", "K+", "Capa_Reten", "Altitude")] #c'est le bon modèle, obtenu avec l'ordistep

#allow to check which variables would be selected. Control if they are correlated ?
#I propose to select :
test=vif.cca(first) 
test#problème (>10)
# 
# 
# mil3=mil[,c("Limon","Argile",'Mg++','K+',"Capa_Reten","Altitude")]
selected=as.data.frame(scale(mil2, center=TRUE, scale=TRUE)) #c'est mil2
# rdadoubs3=rda(flo~.,mil3)
# test=vif.cca(rdadoubs3) 
# test#all good
```

## Partitionnement de variance 

```{r}
#Partition of the Variation of Community with mil and space (xy)
mod <- varpart(flo,mil,xy)
mod
plot(mod, bg=2:5) #on n'expliquera que 9% de la variance, on a 
#conditionnel en vert, 0.07
#mil = 0.09, c'est la partie de flo qui est expliqué par mil.
#on a 0.07 de la variance de flo expliqué par xy
#0.04 par l'interraction. 
#on s'interesse à X1 seulement car on enlèe la dépendance spaciale.

```

## Principal Component Correspondence Analysis 

```{r}
#perform a partial CCA with space removing
ccap=cca(flo,selected,xy,scan=F)
#it should be noticed that the function rda and cca already center and scale the matrices
ccap
summary(ccap)

#test the pCCA:
anova.cca(ccap)

ccap$CCA$v #coordonnées des especes sur les axes
ccap$CCA$biplot #coordonnées des variables

MVA.synt(ccap) #conditionnel = 8.78 c'est xy, constrained = 8.94 c'est mil
par(mfrow=c(1,2))
plot(ccap,scaling=1)
plot(ccap,scaling=2)
goodness(ccap)


#plot the pCCA
par(mfrow=c(1,1))
plot(ccap,scaling=1)
plot(ccap, type="n")
text(ccap, col="blue",cex = 0.75)
text(ccap, dis="cn",col="black",cex = 1.2)
plot(ccap, type="n")
text(ccap, dis="cn",col="black",cex = 1)
text(ccap, "species", col="blue", cex=0.8)
```


# Création d'un modèle à vocation prédictive pour la classe de Association
## Selection du meilleur modèle

```{r}
asso.mlogit = multinom(association$association~.,mil) #modèle multinomial complet
asso = multinom(association$association~1,mil) #modèle multinomial null
beta = coef(asso.mlogit)

model = step(asso, direction = "both", scope = formula(asso.mlogit))
```

Grace à la selection du meilleur modèle, obtenu en minimisant l'AIC, on s'arrête sur les variables K+, Altitude, Capa_Reten et Sable.
```{r}
asso.selected = mil[, c("K+", "Altitude",  "Capa_Reten", "Sable")]
asso.select.mlogit = multinom(association$association~.,asso.selected)
```

On vérifie la multicollinéarité :
```{r}
vif(asso.select.mlogit)
```
La valeur du VIF pour la variable Sable s'élève à 1933, c'est beaucoup trop ! Il s'agira d'enlever cette variable :
```{r}
asso.selected.no.sand = mil[, c("K+", "Altitude",  "Capa_Reten")]
asso.selected.no.sand$K = asso.selected.no.sand$"K+"
asso.selected.no.sand = asso.selected.no.sand[-1]
model_final = multinom(association$association~.,asso.selected.no.sand)

vif(model_final) 
```
Désormais, mode_final ne présentente pas de soucis de multicollinéarité. Nous allons l'utiliser pour réaliser de la prédiction de classe.

## Prédictions
```{r}
proba = predict(model_final, newdata = data.frame(asso.selected.no.sand), type="class")
confusion = table(association$association,proba,dnn=list("Observed","Predicted"))
confusion

## il faudrait la mettre en couleur mais j'ai pas trouvé...

```
